# 테라폼과 다른 코드형 인프라 도구 비교

<br>

**비교 사항**  
- 구성 관리 vs 프로비저닝
- 가변 인프라 vs 불변 인프라
- 절차적 언어 vs 선언적 언어
- 마스터 서버 유무
- 에이전트 유무
- 커뮤니티 규모와 활성화
- 성숙한 기술 vs 최첨단 기술
- 여러 도구를 함께 사용

<br>

## 구성 관리 vs 프로비저닝
### 구성 관리 도구
- Chef, Puppet, Ansible, SaltStack 등

### 프로비전 도구
- CloudFormation, Terraform, OpenStack Heat 등

### 구분 모호
구성 관리 도구도 어느 정도의 프로비전 수행 가능하고 프로비전 도구 역시 어느 정도의 구성 수행 가능

### 도구 선택
서버 템플릿 도구를 통해 이미지를 만들었다면 이 이미지를 실행할 인프라를 프로비저닝해야 하므로 프로비전 도구를 선택하는 것이 최선  
서버 템플릿 도구를 사용하지 않는 경우 구성 관리 및 프로비전 도구를 함께 사용

#### Example
Terraform을 사용하여 서버를 프로비저닝하고 Chef를 실행하여 각 서버 구성

<br>

## 가변 인프라 vs 불변 인프라
### 가변 인프라
- Chef, Puppet, Ansible, SaltStack 등
- 일반적으로 가변 인프라 패러다임을 사용

#### 구성 드리프트
Chef에 새 버전의 OpenSSL을 설치하도록 지시하면 기존 서버에 소프트웨어 업데이트를 실행하고 변경 사항을 적용  
시간이 지나면서 점점 더 많은 업데이트를 적용하는데 그때마다 각 서버는 고유한 변경 기록 작성

결과적으로 매 서버가 약간씩 다를 수 있으므로 진단 및 재현이 어려운 미묘한 구성에 관한 버그 발생 가능성 존재  
(수동 작업에 언급한 구성 드리프트 문제와 동일)

#### 자동화된 테스트 환경
테스트 서버에서는 구성 관리 변경이 제대로 작동할 수도 있지만  
실제 운영 환경의 서버에는 테스트 환경에 반영되지 않은 지난 몇 개월 동안의 변경 사항이 누적

=> 운영 서버에서는 동일한 변경 내용이 다르게 작동할 가능성 존재

### 불변 인프라
- Docker, Packer 등
- Docker 또는 Packer에서 생성한 머신 이미지를 배포하는 경우 대부분의 변경은 완전히 새로운 서버를 배포하는 것과 동일

#### 구성 드리프트
새 버전의 OpenSSL을 배포하는 경우 Packer로 새 버전의 OpenSSL이 포함된 새 이미지를 작성하여 배포한 다음 이전 서버는 종료  
모든 배포는 새로운 서버에서 변경 불가능한 이미지를 사용

이 방식은 구성 드리프트 버그를 줄이고 각 서버에서 어떤 소프트웨어가 실행 중인지 정확하게 알 수 있게 하며,  
이전 버전의 소프트웨어(이전 이미지)로 손쉽게 복원 가능

#### 자동화된 테스트 환경
테스트 환경에서 테스트를 통과한 변경 불가능한 이미지는 운영 환경에도 동일하게 배포되므로 동일한 방식으로 작동

=> 자동 테스트 효율 향상

#### 단점
사소한 변경 사항에도 서버 템플릿에서 이미지를 재구성하고 모든 서버를 재배치하므로 많은 시간이 필요  

불변성은 실제로 이미지를 실행하는 순간까지만 지속  
서버가 가동되어 실행되기 시작하면 하드 드라이브가 변경되므로 어느 정도의 구성 드리프트 발생

<br>

## 절차적 언어 vs 선언적 언어
### 절차적 언어
- Chef, Ansible 등
- 원하는 최종 상태를 달성하는 방법을 단계별로 지정하는 절차적 스타일 코드를 권장

#### 문제점
- **인프라의 마지막 상태 정보를 기록하고 있지 않는다는 점**
  - 템플릿이 적용된 순서까지 알아야 무엇이 배포되었는지 파악 가능  
  - 현재까지 일어난 모든 변화 인지 필요
- **재사용 가능성 제한**
  - 인프라의 현재 상태를 수동으로 고려해야 하므로 재사용성이 본질적으로 제한된다는 것이 단점  
  - 인프라의 상태는 지속적으로 변경되는데 이전 코드를 더 이상 사용할 수 없으니 시간이 지남에 따라 규모가 커지고 복잡

### 선언적 언어
- Terraform, CloudFormation, SaltStack, Puppet, OpenStack Heat 등
- 원하는 최종 상태를 지정하는 선언적 방식의 코드를 권장

절차적 코드와 달리 항상 인프라의 최신 상태를 표시하므로 현재 배포되어 있는 인프라의 내용과 구성을 한눈에 파악이 가능한 점과
현재 상태를 수동으로 설명할 필요가 없으므로 재사용 가능한 코드를 작성하기 쉽다는 점 등이 장점이긴 하나
표현력이 제한되어 있다는 단점 존재

#### 문제점
- 무중단 인프라 변경이 쉽지 않다는 점
- 재사용 가능한 코드 작성이 쉽지 않다는 점
  - if문, 반복문 등 논리를 수행하는 능력 제한

### 코드 비교
#### Ansible Example
10대 서버 배포

```yaml
- ec2:
    count: 10
    image: ami-0fb653ca2d3203ac1
    instance_type: t2.micro
```

배포 후, 15대로 변경

```yaml
- ec2:
    count: 5
    image: ami-0fb653ca2d3203ac1
    instance_type: t2.micro
```

※ 문제점  
이전에 작성한 절차 코드는 더 이상 유용하지 않으므로 서버 수를 15로 업데이트하면 총 25대 서버가 배포되는 결과 초래  
이미 배포된 서버가 어떤 것인지 파악하고 완전히 새로운 절차 스크립트를 작성하여 5대 서버를 추가하는 작업 필요

#### Terraform Example
10대 서버 배포

```terraform
resource "aws_instance" "example" {
  count             = 10
  ami               = "ami-0fb653ca2d3203ac1"
  instance_type     = "t2.micro"
}
```

배포 후, 15대 변경

```terraform
resource "aws_instance" "example" {
  count             = 15
  ami               = "ami-0fb653ca2d3203ac1"
  instance_type     = "t2.micro"
}
```

<br>

## 마스터 서버 유무
### 마스터 서버가 있는 도구
- Chef, Puppet, SaltStack 등

인프라를 업데이트하려면 명령줄 도구(CLI)와 같은 클라이언트를 사용하여 마스터 서버에 새 명령을 실행  
마스터 서버가 업데이트 내용을 모든 서버로 푸시하거나, 서버들이 주기적으로 마스터 서버에서 최신 업데이트를 가져옴

#### 장점
- **마스터 서버는 인프라의 상태를 살펴보고 관리할 수 있는 단일 중앙 저장소 역할 수행**
  - 많은 구성 관리 도구는 마스터 서버에 Chef 콘솔, Puppet 엔터프라이즈 콘솔과 같은 웹 인터페이스를 제공하여 상황을 쉽게 확인 가능
- **어떤 마스터 서버는 백그라운드에서 지속적으로 실행되어, 구성의 일관성 유지**
  - 누군가 서버를 수동으로 변경하더라도 마스터 서버는 변경 사항을 되돌려 놓으므로 구성 드리프트 문제 방지 가능

#### 단점
- **추가 인프라 필요**
  - 마스터를 실행하려면 추가 서버 또는 고가용성 및 확장성을 위해 클러스터링된 서버 필요
- **유지 관리**
  - 마스터 서버를 유지, 업그레이드, 백업, 모니터링 및 확장하는 작업 필요
- **보안**
  - 클라이언트가 마스터 서버와 통신할 방법, 마스터 서버가 다른 모든 서버와 통신할 방법 필요
  - 일반적으로 추가 포트를 열고 추가 인증 시스템을 구성하는데 이러한 구성은 서버가 공격당할 가능성을 증가시키는 요소

### 마스터 서버가 없는 도구
- Ansible, CloudFormation, OpenStack Heat, Terraform 등

#### Example
- **Terraform**
  - 클라우드 업계가 제공하는 API를 이용하여 작동
  - 어떤 의미에서 API 서버가 마스터 서버가 될 수 있지만 추가 인프라나 추가 인증 메커니즘이 필요하지 않으며 사용자의 API 키를 사용해 작동
- **Ansible**
  - SSH로 각 서버에 직접 연결하여 작업
  - 어떤 추가적인 인프라나 추가 인증 메커니즘 관리 불필요

<br>

## 에이전트 유무
### 에이전트 설치 필요
- Chef, Puppet, SaltStack 등
- 에이전트는 일반적으로 각 서버의 백그라운드에서 실행되며 구성 관리 업데이트의 설치 담당

#### 단점
- **부트스트랩**
  - 일회용 명령을 실행하여 클라우드 업체가 제공하는 API로 서버를 할당하고 SSH를 통해 해당 서버에 에이전트 소프트웨어 설치
- **유지 관리**
  - 마스터 소프트웨어와 동기화된 상태를 유지하도록 에이전트 소프트웨어를 정기적으로 업데이트하는 작업 필요
  - 에이전트 소프트웨어를 모니터링하여 문제가 있으면 에이전트 재시작
- **보안**
  - 에이전트 소프트웨어가 마스터 서버에서 구성을 가져오는 경우 모든 서버에 아웃바운드 포트 오픈
  - 마스터 서버가 에이전트에 구성을 푸시하면 모든 서버에서 인바운드 포트 오픈
  - 통신 중인 서버에 에이전트를 어떻게 인증할 것인지 고려
  - 서버가 공격당할 가능성 증가
- **복잡도 증가**
  - 구성 요소 간 관계가 복잡해지면 인프라에 다양한 장애 발생 가능성 증가
  - 애플리케이션 코드, 인프라 코드, 구성 관리 클라이언트, 마스터 서버의 버그, 클라이언트가 마스터 서버와 통신하는 방법 및 다른 서버가 마스터 서버와 통신하는 방법 중 어디에서 버그가 발생하는지에 대한 모니터링 필요

### 에이전트 설치 불필요
- Ansible, CloudFormation, OpenStack Heat, Terraform 등

#### Example
- **Terraform**
  - 마스터 서버와 에이전트가 없는 아키텍처 사용
  - AWS, Azure, GCP 등의 클라우드 업체는 각각 물리적 서버에 에이전트 소프트웨어를 설치하여 관리 및 인증 수행
  - 테라폼 클라이언트만 실행하면 클라우드 공급자의 API를 사용하여 나머지 모든 것을 처리
- **Ansible**
  - 서버가 SSH 데몬을 실행해야 하는데 SSH 데몬은 대부분 서버에서 실행되므로 추가 작업 불필요

<br>

## 커뮤니티 규모와 활성화
대부분의 경우 프로젝트 주변의 생태계가 기술 자체의 품질보다 사용자 경험에 더 큰 영향을 줄 수도 있으므로  
기술을 선별할 때 커뮤니티도 중요하게 고려해야 할 요소 중 하나

### 고려 요소
- 프로젝트에 참여하는 사람 수
- 사용 가능한 플러그인 수
- 통합 및 확장 프로그램 수
- 블로그 게시물
- Stack Overflow 등

<br>

## 성숙한 기술 vs 최첨단 기술
기술을 선택할 때 고려해야 할 또 다른 주요 요소는 기술의 성숙도

Terraform은 여태 언급한 다른 도구들에 비해 가장 최근에 나온 것이고 1.0.0 이전의 버전이므로  
안정적이지 않고 이전 버전과 호환되는 API를 보장하지 않으며, 버그 존재 가능성 보유  

※ 2022년 11월 기준으로 1.3.5 버전까지 나왔으므로 앞서 얘기한 문제들이 개선되었을 가능성 존재

<br>

## 여러 도구를 함께 사용
### 프로비저닝과 구성 관리
#### Terraform과 Ansible
Terraform을 사용하여 기본 인프라 배포 -> Ansible을 사용하여 서버에 앱을 배포

Terraform과 Ansible은 클라이언트 전용 응용 프로그램으로써 추가로 실행할 인프라가 없고 두 개를 함께 작동시킬 수 있는 여러 가지 방법 존재  
Terraform이 서버에 특별한 태그를 추가하고 Ansible은 이 태그를 이용하여 서버를 식별 및 구성을 진행

그러나 일반적으로 Ansible을 변경 가능한 형태로 사용하면 절차적인 요소가 많은 코드를 작성해야 하므로  
인프라 및 조직이 성장함에 따라 유지 관리가 어려워질 수 있다는 단점 존재

### 프로비저닝과 서버 템플릿
#### Terraform과 Packer
Packer를 사용하여 앱을 VM 이미지로 패키징 -> Terraform을 사용하여 VM 이미지를 실행하는 서버 및 기본 인프라 배포

Terraform과 Packer는 모두 클라이언트 전용 응용 프로그램이므로 추가로 실행할 인프라가 없어 초반에 쉽게 접근 가능  
또한 불변 인프라 접근 방식이므로 유지 관리가 용이

하지만 먼저 VM을 구축하고 배포하는 데 시간이 오래 걸리므로 배포 속도가 느려질 수 있다는 점과  
Terraform으로 구현할 수 있는 배포 전략이 제한적이라는 점이 단점

### 프로비저닝과 서버 템플릿 그리고 오케스트레이션 도구
#### Terraform, Packer, Docker 그리고 Kubernetes
Packer를 사용하여 Docker 및 Kubernetes가 설치된 VM 이미지 생성 -> Terraform을 사용하여 VM 이미지를 실행하는 서버 및 기본 인프라 배포 -> 서버가 구동되면 컨테이너로 된 애플리케이션을 Kubernetes에서 실행

Docker 이미지가 상당히 빠르게 빌드되고 로컬 컴퓨터에서 이미지를 실행하여 테스트할 수 있으며  
다양한 배포 전략, 자동 복구, 자동 확장 기능을 포함하여 Kubernetes의 모든 내장 기능 활용 가능하단 점이 장점

하지만 추가적인 인프라가 필요하므로 운영이 복잡해진다는 점과 추가적인 학습이 필요하다는 점, 관리 및 디버깅을 해야 한다는 것이 단점  
다행히도 주요 클라우드 공급자가 세심하게 관리되는 Kubernetes 서비스를 제공하고 있어 운영의 일부를 신경 쓰지 않아도 됨
